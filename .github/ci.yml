name: CI

on:
  push:
    branches: [ main, backend/ch ]
    tags: [ 'v*' ]  # v로 시작하는 태그도 CI 트리거
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: us-east-1  # ECR Public은 us-east-1만 지원
  ECR_REGISTRY: public.ecr.aws/v3g6g4v7

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Set up Python 3.9
      uses: actions/setup-python@v4
      with:
        python-version: 3.9
    # 테스트 코드는 기존 유지

  build-and-push:
    runs-on: ubuntu-latest
    needs: test
    strategy:
      fail-fast: false  # 한 서비스 실패 시 다른 서비스 취소 방지
      matrix:
        include:
          - service: admin-service
            repository: cj-admin-svc
            path: admin-service
          - service: auth-service
            repository: cj-auth-svc
            path: auth-service
          - service: booking-service
            repository: cj-booking-svc
            path: booking-service
          - service: flight-service
            repository: cj-flight-svc
            path: flight-service
          - service: payment-service
            repository: cj-payment-svc
            path: payment-service

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # 전체 히스토리와 태그 가져오기

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR Public
      id: login-ecr-public
      uses: aws-actions/amazon-ecr-login@v2
      with:
        registry-type: public

    - name: Extract version from commit message
      id: version
      run: |
        # 커밋 메시지에서 버전 추출 (v1.0.0, v2.0.1 등)
        COMMIT_MSG="${{ github.event.head_commit.message }}"
        echo "Commit message: $COMMIT_MSG"
        
        # v로 시작하는 버전 패턴 찾기
        if echo "$COMMIT_MSG" | grep -q "v[0-9]\+\.[0-9]\+\.[0-9]\+"; then
          VERSION=$(echo "$COMMIT_MSG" | grep -o "v[0-9]\+\.[0-9]\+\.[0-9]\+" | head -1)
          echo "Version found: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "has_version=true" >> $GITHUB_OUTPUT
        else
          # 버전이 없으면 자동 증가 버전 생성
          echo "No version found in commit message, generating auto version..."
          
          # 이전 태그들에서 최신 버전 찾기
          LATEST_TAG=$(git tag --sort=-version:refname | grep '^v[0-9]' | head -1)
          
          if [ -z "$LATEST_TAG" ]; then
            # 첫 번째 버전
            VERSION="v1.0.0"
            echo "First version: $VERSION"
          else
            # 마이너 버전 증가
            MAJOR_MINOR=$(echo "$LATEST_TAG" | cut -d. -f1,2)
            PATCH=$(echo "$LATEST_TAG" | cut -d. -f3)
            NEW_PATCH=$((PATCH + 1))
            VERSION="${MAJOR_MINOR}.${NEW_PATCH}"
            echo "Auto version: $VERSION (from $LATEST_TAG)"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "has_version=true" >> $GITHUB_OUTPUT
        fi
        
        echo "Final version: $VERSION"

    - name: Check for changes
      id: changes
      run: |
        # Git diff로 실제 변경된 파일 감지
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # 현재 서비스와 관련된 파일이 변경되었는지 확인
        SERVICE_PATH="${{ matrix.service }}"
        
        # 서비스 디렉토리에 변경 사항이 있는지 확인
        if echo "$CHANGED_FILES" | grep -q "^$SERVICE_PATH/"; then
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "✅ ${{ matrix.service }} has changes - will build image"
        else
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "⏭️ ${{ matrix.service }} no changes - skipping build"
        fi
        
        # 디버깅 정보 출력
        echo "Service: ${{ matrix.service }}"
        echo "Path: $SERVICE_PATH"
        echo "Dockerfile: $SERVICE_PATH/Dockerfile"
        echo "Directory exists: $([ -d "$SERVICE_PATH" ] && echo "YES" || echo "NO")"
        echo "Dockerfile exists: $([ -f "$SERVICE_PATH/Dockerfile" ] && echo "YES" || echo "NO")"

    - name: Build and push Docker image
      if: steps.changes.outputs.has_changes == 'true'
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        REPO="${{ env.ECR_REGISTRY }}/${{ matrix.repository }}"
        
        # 서비스 디렉토리에서 Docker 이미지 빌드
        if [ -f "${{ matrix.service }}/Dockerfile" ]; then
          cd ${{ matrix.service }}
          
          echo "Building image for ${{ matrix.service }} with version $VERSION"
          
          # 이미지 빌드 (여러 태그로)
          docker build -t $REPO:$VERSION -t $REPO:latest .
          
          # 이미지 푸시
          echo "Pushing $REPO:$VERSION"
          docker push $REPO:$VERSION
          
          echo "Pushing $REPO:latest"
          docker push $REPO:latest
          
          echo "Successfully built and pushed ${{ matrix.service }}:$VERSION and :latest"
        else
          echo "Dockerfile in ${{ matrix.service }} not found, skipping..."
        fi
        
        # 이전 latest 태그 제거 (선택적)
        echo "Cleaning up old latest tags..."
        
        # 현재 latest가 아닌 이미지들의 latest 태그 제거
        # (ECR에서는 태그만 제거하고 이미지는 유지)
        aws ecr-public batch-delete-image \
          --repository-name ${{ matrix.repository }} \
          --image-ids imageTag=latest \
          --region us-east-1 \
          --registry-id public.ecr.aws/v3g6g4v7 \
          || echo "No previous latest tag to remove"
        
        # 새로운 latest 태그 다시 설정
        echo "Setting new latest tag for $VERSION"
        docker tag $REPO:$VERSION $REPO:latest
        docker push $REPO:latest

    - name: Save built service info
      if: steps.changes.outputs.has_changes == 'true'
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        SERVICE="${{ matrix.service }}"
        REPOSITORY="${{ matrix.repository }}"
        
        # 빌드된 서비스 정보를 파일에 저장
        mkdir -p deployment-info
        echo "service=$SERVICE" > deployment-info/$SERVICE.env
        echo "repository=$REPOSITORY" >> deployment-info/$SERVICE.env  
        echo "version=$VERSION" >> deployment-info/$SERVICE.env
        echo "built_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> deployment-info/$SERVICE.env
        
        echo "Saved deployment info for $SERVICE with version $VERSION"

    - name: Upload deployment artifacts
      if: steps.changes.outputs.has_changes == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: deployment-info-${{ matrix.service }}
        path: deployment-info/${{ matrix.service }}.env
        retention-days: 1

  collect-deployment-info:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: always()  # build-and-push가 실패해도 실행
    steps:
    - name: Download all deployment artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: deployment-info-*
        merge-multiple: true
        path: deployment-info

    - name: Create deployment summary
      run: |
        echo "Built services summary:"
        BUILT_SERVICES=()
        VERSION=""
        
        if [ -d "deployment-info" ]; then
          for file in deployment-info/*.env; do
            if [ -f "$file" ]; then
              echo "Processing: $file"
              cat "$file"
              
              # 서비스명과 버전 추출
              SERVICE=$(grep "service=" "$file" | cut -d'=' -f2)
              VER=$(grep "version=" "$file" | cut -d'=' -f2)
              
              BUILT_SERVICES+=("$SERVICE")
              VERSION="$VER"  # 모든 서비스가 같은 버전 사용
              
              echo "Added $SERVICE to built services list"
            fi
          done
        fi
        
        # 빌드된 서비스 목록을 comma-separated string으로 변환
        IFS=','
        SERVICES_STRING="${BUILT_SERVICES[*]}"
        unset IFS
        
        echo "BUILT_SERVICES=$SERVICES_STRING" >> $GITHUB_ENV
        echo "DEPLOYMENT_VERSION=$VERSION" >> $GITHUB_ENV
        
        echo "Final built services: $SERVICES_STRING"
        echo "Deployment version: $VERSION"

    - name: Create deployment trigger file
      run: |
        mkdir -p deployment-trigger
        echo "built_services=${{ env.BUILT_SERVICES }}" > deployment-trigger/info.env
        echo "version=${{ env.DEPLOYMENT_VERSION }}" >> deployment-trigger/info.env
        echo "commit_sha=${{ github.sha }}" >> deployment-trigger/info.env
        echo "workflow_run_id=${{ github.run_id }}" >> deployment-trigger/info.env
        
        echo "Created deployment trigger with:"
        cat deployment-trigger/info.env

    - name: Upload deployment trigger
      uses: actions/upload-artifact@v4
      with:
        name: deployment-trigger
        path: deployment-trigger/info.env
        retention-days: 1

    - name: Trigger CD Pipeline via Repository Dispatch
      if: env.BUILT_SERVICES != ''
      uses: actions/github-script@v7
      with:
        script: |
          const builtServices = '${{ env.BUILT_SERVICES }}';
          const version = '${{ env.DEPLOYMENT_VERSION }}';
          
          if (builtServices) {
            console.log(`Triggering CD for services: ${builtServices} with version: ${version}`);
            
            await github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'deploy-services',
              client_payload: {
                built_services: builtServices,
                version: version,
                commit_sha: '${{ github.sha }}',
                workflow_run_id: '${{ github.run_id }}'
              }
            });
            
            console.log('✅ CD Pipeline dispatch event sent successfully');
          } else {
            console.log('No services to deploy, skipping CD trigger');
          }

  create-tag:
    runs-on: ubuntu-latest
    needs: build-and-push
    if: always()  # build-and-push가 실패해도 실행
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Extract version from commit message
      id: version
      run: |
        # 커밋 메시지에서 버전 추출 (v1.0.0, v2.0.1 등)
        COMMIT_MSG="${{ github.event.head_commit.message }}"
        echo "Commit message: $COMMIT_MSG"
        
        # v로 시작하는 버전 패턴 찾기
        if echo "$COMMIT_MSG" | grep -q "v[0-9]\+\.[0-9]\+\.[0-9]\+"; then
          VERSION=$(echo "$COMMIT_MSG" | grep -o "v[0-9]\+\.[0-9]\+\.[0-9]\+" | head -1)
          echo "Version found: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "has_version=true" >> $GITHUB_OUTPUT
        else
          echo "No version found in commit message"
          echo "has_version=false" >> $GITHUB_OUTPUT
        fi

    - name: Create Git tag
      if: steps.version.outputs.has_version == 'true'
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        
        # 원격 저장소에서 태그 존재 여부 확인
        if git ls-remote --tags origin | grep -q "refs/tags/$VERSION$"; then
          echo "Git tag $VERSION already exists remotely, skipping..."
        else
          echo "Creating git tag: $VERSION"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag $VERSION
          git push origin $VERSION
          echo "Git tag $VERSION created and pushed"
        fi

